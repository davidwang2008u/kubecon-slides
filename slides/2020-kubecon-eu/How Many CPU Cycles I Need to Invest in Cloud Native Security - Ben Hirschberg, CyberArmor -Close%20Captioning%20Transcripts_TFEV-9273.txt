How Many CPU Cycles I Need to Invest in Cloud Native Security?: TFEV-9273 - events@cncf.io - Thursday, August 20, 2020 7:45 AM - 41 minutes

Participant: wordly [W] English (US)

Transcription for wordly [W]

00:00:01 [W] Hi, I'm Ben.
00:00:07 [W] Here's Bergamot going to talk to you today about how many CPU Cycles you need to invest in your Cloud security so really short about me.
00:00:19 [W] me. I'm the next white hat hacker with a long history of security and testing and development and today. I'm an entrepreneur in the cognitive.
00:00:31 [W] Field and the collective security field to be more precise and I have few Hobbies one of them stitching and and I love to present such interesting things that like what I'm going to present to you
00:00:46 [W] a so
00:00:49 [W] what we're going to do today is we are going to talk about TLS and in Cloud native and how much we need to invest in TLS.
00:00:59 [W] We are going to run some benchmarking tests will try to understand how much we want me to invest in order to move from non-protected connections to TLS will try to learn together.
00:01:13 [W] They're how these numbers are built up and at the end.
00:01:22 [W] Hopefully I will be able to to tell you a few improvements you can make to take to improve the time you're performing teachers performance.
00:01:30 [W] what is why are we talking about TLC and Cloud security and so so in general obviously all of us know that that in the recent
00:01:43 [W] I can say 10 15 years cyber attacks has leads to higher level and we see that these many many not just many money goes into the protection, but
00:01:57 [W] So a lot of money going into the attacks and and there is a big interest in attacking systems. And therefore when we are moving to the cloud and somehow we are even a little bit losing
00:02:13 [W] Our connection with our physical systems. We even need to invest a little more into our security than before and TLS is Cornerstone of cloud security.
00:02:26 [W] Okay, and although we have to do all of this while keeping our expenses at a reasonable level.
00:02:33 [W] Okay.
00:02:39 [W] Okay.
00:02:43 [W] So what is TLS?
00:02:49 [W] I don't want to speak too much about it because this is not a security lecture.
00:02:54 [W] I assume that you have some knowledge of TLs but just for the sake of the discussion Cynthia's the security communication protocol today, it contains
00:03:04 [W] We all almost interesting secure protocol security features, which we need in a secure connection protocol.
00:03:17 [W] We have confidentiality encryption Integrity which is message authentication authenticity where we can validate the communicate the communicating parties in our
00:03:29 [W] connection and all these are given TS gives these features and it does does it by using nearly all of the new and modern cryptography teams are around in the world
00:03:44 [W] And just continuously updated list of cryptography rooms depending on whether a new algorithm comes up or something becomes broken and going
00:03:59 [W] Work what we really need to understand is what are the parts which are building up TLS in order to understand how much you need to invest we have to break the protocol into the into the part its parts and see which parts does what and how much time it takes.
00:04:14 [W] So the handshake protocol is is the first part of vanity as connection establishment.
00:04:26 [W] It has two main goals.
00:04:30 [W] Okay, one goal is to authenticate the the communication parties in the connection whether it is a see one part TLS, which we call what single-sided TLS or
00:04:41 [W] A mutual TLS where we are both parties are authenticating the other when it does is is authenticated.
00:04:54 [W] We're really talking to one to whom we wanted to talk and the second important part is that it creates what we call a session key.
00:05:05 [W] So handshake protocol is is results in two things main things one is the authentication of the pier. The second is the creation of a session key now the session
00:05:11 [W] A key is a symmetric key.
00:05:18 [W] Okay, the handshake protocol mostly is based on as symmetric cryptography.
00:05:22 [W] Okay, as soon as I don't want to go into the deeper right now, but but in order to authenticate the pier without knowing its Secrets is based on the by a symmetric cryptography but a symmetric
00:05:33 [W] Cryptography is computation the high demanding field and on contrary symmetric cryptography is which is used by the application protocol is less computationally
00:05:49 [W] Confessional intensive field and therefore the main goals is of the energy particle is to create a symmetric key between the two parties whose haven't
00:06:04 [W] That before and the application protocol which is the main part from the application point of view of the TLs protocol is actually the part where we're TLS takes the application
00:06:19 [W] Data will be HTML or grpc or any other kind of tcp-based protocol and wraps it in a secure and closing encrypts the data and creates a
00:06:34 [W] you'll simply creating altinity gation code which enables the other side to validate the really got the original message it wanted to get and this is done using symmetric cryptography using the session key created in the handshake protocol
00:06:50 [W] The third part of the TLs protocol is other protocol, which is not really interesting for the sake of our discussion today.
00:07:03 [W] But but for the completeness, I'm telling you that there exists another category that doesn't have to really do something with cryptography.
00:07:09 [W] It's only a way to learn the other side.
00:07:10 [W] That's something really went wrong with with the signatures or other parts of the hand. She poured application protocol and other the other side. That's something
00:07:21 [W] is wrong and we are going to disconnect.
00:07:24 [W] So as I told you we are going to mostly talk about about CPU today, and I wanted to give you an outline of in computational intensity of the energy program
00:07:42 [W] Issue protocol as the opening of our discussion. If you look at 10 G Brach ones how much CPU it needs as I told you before it is based on estimates of cryptography and aesthetic cryptographic takes time
00:07:57 [W] It's CPU.
00:08:04 [W] So it's for a short time but it loads the CPU really pretty heavily relatively and and and this has to be taken into account on the other hand. The henchy
00:08:13 [W] Of the diffuser really matter much RAM and uses a few kilobytes, but but it's not something that really worried us all together and also for networks but perspective the haproxy.
00:08:28 [W] is staking a few kilobytes at the beginning of every session opening which if we compare against pure TCP connections, which was
00:08:44 [W] Of a few tens of bytes. There is some considerable addition at the connection opening at the overhead to TLS on the other hand. If you look at the application protocol as I told you before this is symmetric cryptography of the application protocol
00:08:59 [W] Is rather be relatively less CPU intensive, but obviously this has to take into account the the number of bikes which is being transferred over application protocol. So if we take the
00:09:14 [W] A protocol is given every connection open is this is a constant Number application protocol CPU uses depends on the number of bytes, which is meant to be transferred over the connection.
00:09:26 [W] Therefore. This is really a relative impression.
00:09:38 [W] I can tell you at the stake, but but but it's a little less than handshake CP intensive than the haproxy ball itself the same goes from RAM on from their own perspective.
00:09:44 [W] Active the application protocol is not really using more RAM than than without using the without TLS and also its overhead over the wire is is pretty small.
00:10:00 [W] It's like 20 30 bytes per Tia's frame, which is like something we can easily and manage also wanted to before going into the benchmarking to talk about the types.
00:10:13 [W] Of TLS and the use cases so we have north-south traffic use case, which is mostly the endpoint talking to our backend side to you. Usually today talking in the crowd into application load balancers
00:10:29 [W] Of some type of for Ingress controller and there is a TLS termination usually at this stage. So usually the incoming TLS against the public internet is one-sided
00:10:44 [W] Because usually the clients endpoints want to verify before they send some kind of authentication token or or or credential they want to verify that they are talking to the right server
00:10:59 [W] The real point of validating the endpoint identity at this stage.
00:11:05 [W] So it's one-sided TLS and and and usually we terminated somewhere at the beginning because you see application load balancers Ingress controllers usually want to look into the the TLs
00:11:19 [W] Jeff into the traffic the application Level of the traffic in order to do an intelligent stuff on the other side.
00:11:31 [W] We have the East-West traffic.
00:11:35 [W] Okay and up until the code transition.
00:11:37 [W] Okay. We usually is closed the East-West traffic within firewalling into a perimeter.
00:11:44 [W] But today going into the cloud knative World. Okay, these old parameter set ups and concepts are.
00:11:49 [W] Less and less elastic and expandable and therefore we are we see that more and more that that the East-West traffic needs to be protected because there is no clear perimeter around there
00:12:04 [W] 3 I 3 examples which are broadly how to do East-West set up one is some moment, which I called home brew taking taking existing applications that adding TLS to them, which is a
00:12:19 [W] Come complex from the men from the operational part point of view because we start to have to manage every service with its own private keys and certificates, which is a big fuss.
00:12:33 [W] And therefore we have our servicemeshcon lucian's like he Co which are using site cars and within sidebar. We are using for the same purpose.
00:12:46 [W] We are using particularly in light based setup where we aren't using a sidecar prophecy, but we are adding an extra component to the process in order to upgrade existing connections TLS and
00:13:00 [W] Both in history, and in our case, we are managing the certificates and private Keys instead of the application developers or The Operators.
00:13:10 [W] Okay, but in this East-West case really see more dominance of futurewei TLS use case where both Services which are talking to each other authenticating themselves to each other.
00:13:23 [W] Okay, and we have to note here that both Mutual TLs are adding extra CPU usage because of
00:13:30 [W] the secondary authentication and the sidecar proxy is adding extra RAM and CPU usage to the system.
00:13:42 [W] So my simple setup started from from adding using a pad Apache jmeter against and a simple nginx static web server.
00:13:51 [W] I've used different file sizes in the static web servers 1 by x 1 kilobyte 1 Megabyte and hundred megabyte and gave it.
00:14:00 [W] our CPUs / / microservice and I started to run my Benchmark first Benchmark and I got to initiate a really dramatic initial results because what I saw that
00:14:15 [W] That if we are going moving from from clear to to TLs are our performances dropping very rapidly.
00:14:27 [W] So if I'm looking at the right side requests per second, if I'm requesting a bite one bite file from the web server from going from four thousand requests per second to merely
00:14:40 [W] 300 if I'm going to the other other end of the scale and going to files with with a hundred megabyte content that can see that although
00:14:55 [W] The ratio is not one to ten but still want to for and it's pretty high ratio.
00:15:03 [W] So at this time I was you know, not that I was puzzled, but I saw that this is not really a good way to calculate things and get to somewhere from here and and I went through to
00:15:17 [W] To do some calculations doing a bottom-up calculations to understand how much how much every part of the TOs takes and how much additional it gives to my existing application using
00:15:32 [W] Both Network capture and after the performance monitoring tools like Perth.
00:15:44 [W] I've calculated rough numbers of TS handshake.
00:15:47 [W] I got the numbers that they are as handshake constantly never connection takes like around two milliseconds on the client side and around 1 millisecond at the CPU side the server side.
00:15:59 [W] This is for for server certificate validation.
00:16:11 [W] But if we are doing Mutual certificate validation by two sides, then obviously the client CPU time goes up also server CPU time goes up a little and I got to sorry. I got two measurements
00:16:18 [W] Of two point five milliseconds per site calculating TS handshake.
00:16:33 [W] Now, this is given one of the most today's in 2020 the most common key exchange and handshake algorithms, like elliptic curve.
00:16:38 [W] diffie-hellman with RSA signatures and to kilobits keys.
00:16:46 [W] I did the same traded them make up same rough.
00:16:49 [W] Purrs for for the application protocol when in the application protocol we do encrypt every bite and and hashed them also to create message authentication code.
00:17:04 [W] I get to the numbers of 250 megabytes per second for an AES 256 bandwidth and for message authentication like
00:17:14 [W] 300 megabytes per second for shall three 256.
00:17:22 [W] Okay, and these are rough numbers and we'll try to improve that event. But this is something of good good start and from this psychic see that that we can get to something like a hundred and forty-three
00:17:35 [W] Megabyte per second. We need to calculate with as a bandwidth for a CPU.
00:17:44 [W] So and this is sorry. This is going to be the hardest part of our discussion.
00:17:53 [W] I hope it is not that hard but I've created a small and simple simple formula for calculating this Toc overhead. Okay took into account the number of transaction. I want to make which is M the 80s the client or the server
00:18:07 [W] I didn't CPU time we need for the handshake as is the encryption bandwidth and T is the bikes in one transaction and using this formula.
00:18:18 [W] I want to calculate the overheads of TLS of how much time I need 4 X4 n transactions to calculate TLS or on the other hand.
00:18:30 [W] I can calculate also an inverter this this formula and and I calculated how many
00:18:38 [W] as I can make it making a given time.
00:18:42 [W] So using using this formula, I could represent what we need to know and what need to calculate on the one hand. You can see here in the first line that that on the I start by beginning to calculate
00:18:54 [W] / of of time we need for for the handshake both on the client and server side. And on the list on the left side. I can see I've added how much time I need for encrypting and validating
00:19:09 [W] The application and the application protocol messages for TLS. And from this I could explain how much how many transactions I can do within
00:19:25 [W] Simple second by inverting this formula. So I took return to my original test setup. But this time I've used only the single core I've created a test
00:19:40 [W] Which I call him test web creation one.
00:19:44 [W] We're in everything has dual citizenship are everything TCP connection?
00:19:51 [W] I don't use keep alive.
00:19:57 [W] What I do is I've I've using the same trip to parameters as described before and I'm requesting one kilobyte of application data per transaction transaction, and I got to
00:20:06 [W] Birds where where I could calculate the results using my formula and I get to three hundred Thirty-One thirty-two if I round up transactions per per second and and
00:20:22 [W] And when I look in running the same test on jmeter Cut to 328 transactions per second, which is shows as really cause. It's 1% difference between the theoretical and actual
00:20:38 [W] Numbers I did the same for my second application where I've used a hundred megabyte application data per transaction.
00:20:52 [W] I got in the my formula. I got to 0.68 transactions per second and when I ran it through jmeter,
00:21:02 [W] Okay, I see so 0.7 transaction per second, which is again.
00:21:09 [W] It is pretty close and and I was no more or less good with my formula here.
00:21:22 [W] But if I if I want to express conclude my formula what I know. I have a service where I have five thousand requests and I have mutual TLS and the agency to
00:21:29 [W] These are two point five million.
00:21:30 [W] Mmm.
00:21:31 [W] I have milliseconds and I have this crypto brand with of application data when I'm using my formula. I'm gets and calculated how much time I need CPU time.
00:21:46 [W] I need to for these transactions.
00:21:50 [W] 25 seconds for five thousand requests, which is you know, it's if you
00:21:59 [W] For the first link, it's it's a lot of a lot of overhead and we understand that the main component here is the handshake protocol itself.
00:22:13 [W] Now if we look into the handshake protocol how we can improve the handshake protocol itself at the first step. We have to understand what kind of algorithms we are using in the handshake protocol.
00:22:23 [W] And as I told you before we are using it to curve diffie-hellman for the case change algorithm.
00:22:28 [W] There is no real contest here because the other we could use RSA but are using are safe for key exchange. Algorithm has what we call forward secrecy problems.
00:22:43 [W] It means that if someone records today the conversation is not able to decrypt it an attacker is able to decrypt it.
00:22:53 [W] He steals it's my private key later on like in five years.
00:23:00 [W] He will be able to decrypt my old train traffic.
00:23:08 [W] If I'm using metallic what we call forward secrecy algorithms, like diffie-hellman.
00:23:11 [W] It means that even if someone steals my key in in a year, it won't be able to decrypt old all the traffic and this is obviously very very preferable.
00:23:20 [W] Well today so therefore it is very prefer to use active curve diffie-hellman.
00:23:30 [W] Also, the key psyche exchange signing algorithm is RSA with the with key size of 2 kilo bits, which are 256 the same for the certificate validation.
00:23:41 [W] These are the smallest.
00:23:43 [W] These are actually more or less default numbers today and I have to tell you that that going from down there using smaller piece syseleven.
00:23:49 [W] And older has she's is is really going to hurt your security.
00:23:56 [W] Therefore there is not really much space here to to improve your handshake.
00:24:05 [W] What do you can improve your handshake is what you call the world of expedited handshakes.
00:24:13 [W] I brought you two examples one is client-side session ticket.
00:24:18 [W] It is a it's defined in their ts rfc's it enables the client.
00:24:19 [W] Request from the server on opening the TLs session to give him a session ticket the session tickets contains the session key and Cryptid only for the server itself. So the client cannot look into it, but does not the
00:24:35 [W] Because what enables that if the kind coredns causes the connections and decides to reconnect the same server can take the same tickets and and do an expedited handshake protocol with the where the server is
00:24:50 [W] Taking the ticket decrypted and looks using it as a session key, which is like 10 times faster than then recreating doing a new key exchange and it obviously requires the client to remember
00:25:05 [W] this tickets of the and Associated to the servers but on the other hand after the creation of the form first handshake, you don't really need to add more to your to your c*** transactions,
00:25:20 [W] It's very very fast the same with the pre-shared key is the pre shared key is is is a protocol where th you can use TLS with symmetric trees pre shared among the parties.
00:25:33 [W] It is very fast the same enables. Also, even the first connection to be done without full key for key exchange, but but it really has a big burden of pre sharing symmetric keys, and it's it's really
00:25:47 [W] They suddenly see a solution. So it's not really good for for cognitive environment.
00:26:00 [W] So just to show you that if we assume I return to thy previous calculation with the formula and assume that we have a session tickets and our handshake time is going down by an order of magnitude.
00:26:10 [W] Me too.
00:26:12 [W] Okay from 2 and 1/2 milliseconds to the tenth time. We can see that also the time we need to complete the full five thousand handshake.
00:26:25 [W] Five thousand connections is 2.1 seconds Which is less than obviously a very good Improvement here.
00:26:38 [W] So so appreciate session tickets are really good for for performance talking about the application protocol. The application protocol is is on the one hand. It can be improved and it has a big effect
00:26:49 [W] Especially on the on applications which uses big big chunk of memories transferred between the two parties mostly today. Most new CPU supporting
00:27:04 [W] Which gives you a fantastic throughput and its harbor supported in most Intel chips, make sure that your applications are are using it and and using a Sni because it's
00:27:19 [W] Improves your performance very much in the application protocol. If you don't have Hardware support mostly in iot devices and embedded devices. You can still use chat which is a less secure algorithm day than a yes, but still a very good one
00:27:34 [W] And it's less time and CPU consuming the for message authentication.
00:27:42 [W] We are suggesting to look into authenticated encryption, which are mostly is gcd like protocols where you don't need to go through
00:27:56 [W] Message and they give away their output in the application protocol against shells and other message authentication protocols.
00:28:11 [W] So I suggest you looking into ASG CD from this part.
00:28:21 [W] I think that that we've ended my main parts of our discussion.
00:28:24 [W] I will be happy to answer your questions now.
00:28:26 [W] Now in QA and thank you for your attention.
00:28:29 [W] Hi everyone.
00:28:49 [W] Now I'm taking care of the questions after the presentation.
00:28:57 [W] So the first question is about whether to use RSA or ecdsa the kuma the questioner asked that says that I heard that ecdsa is less CPU intensive
00:29:06 [W] On the server side, but more intensive on the client side.
00:29:14 [W] So this anywhere in so in a scenario where both of the client and server is located in our data center service the service Mutual TLS is ecdsa really beneficial over TSL or RSA?
00:29:23 [W] So it's a really good question.
00:29:28 [W] They're actual to two things to think about one is the security.
00:29:35 [W] Okay, as I said setting the presentation using ecdsa for for key exchange algorithm.
00:29:44 [W] It has a big benefit from the security side. So you don't you have forward secrecy, which means that if someone records today your conversation,
00:29:54 [W] it cannot decrypt it, but we'll be able to take your keys still them later phase you will able to decrypt them. If you are using RSA on the other hand if they are using defilement based algorithms like
00:30:08 [W] Ecdsa then then I think that the better use is the the this the elliptic curve
00:30:23 [W] Defilement k8s change on the other hand. There are essay has a big big performance upside on usually on the client side because when the server
00:30:38 [W] Our says there is none tweak that in RSA. The public key can be a very small number and using very small number means that there has to be less computation to be done and and using
00:30:53 [W] RSA is can be beneficial on the client side.
00:31:03 [W] But again the question here relates more to service the service Mutual TLS case.
00:31:06 [W] We're in the same data center.
00:31:10 [W] I think that that that using RSA elliptic curves doesn't really have a big effect because on the other hand the server will work harder and if this is a symmetric case, I
00:31:22 [W] I would say that there won't be here a big performance Improvement.
00:31:26 [W] Yeah, let's see the next question.
00:31:33 [W] So why I'm waiting for for the next next question. I'm returning to this original question of whether to use RSA or ecdsa LED
00:32:09 [W] Of the curve algorithms are usually have a better performance overall.
00:32:20 [W] So usually if we are we have the same we are keeping, you know using this we are providing say two sides of the conversation we have to take into account
00:32:30 [W] Both sides both sides then then then I think that that is elliptic curves are making a really good case.
00:32:44 [W] But if we can say that the that we are holding one side of the conversation and we want to take its performance into the context like if you have an endpoint, which is
00:32:54 [W] Power consumption device or any kind of other device which has limited from the computational perspective RSA has a good tweaked. So there is here no black and white answer but really, you know, it's nice
00:33:09 [W] Engineering question which where the application specific parameters of a specific application has to be taken into the account.
00:33:17 [W] If there are more questions, I will happy to take here. If no then I will be moving on to the slack Channel after this presentation and I will be happy to answer more questions.
00:34:50 [W] if needed
00:34:52 [W] Yeah.
00:35:59 [W] Okay, so we yeah, we've met we are moving to slack right now.
00:36:09 [W] To take friends questions there.
00:36:14 [W] I was glad that you attended my speech.
00:36:15 [W] I will happen my lecture.
00:36:17 [W] I'll have it to talk to you later.
00:36:19 [W] Bye.
