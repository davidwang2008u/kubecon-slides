Simplify Your Cloud Native Application Packaging and Deployments: YZHH-9096 - events@cncf.io - Wednesday, August 19, 2020 7:36 AM - 66 minutes

Participant: wordly [W] English (US)

Transcription for wordly [W]

00:02:34 [W] Hi everyone, and welcome to my tool.
00:03:01 [W] Hi everyone, and welcome to my talk today.
00:08:38 [W] I'll be talking about how to simplify your Cloud native application packaging and deployments.
00:08:44 [W] My name is Kris Krohn and I work at Docker on developer tooling we responsible for things like Docker compose darker engine and the new Cloud Integrations for AWS ccs and 4-0 ACI.
00:08:55 [W] Let's take a look at the agenda for today's talk will start with what a cloud native application is.
00:09:02 [W] We'll take a look at some of the packaging and deployment challenges or them. I'll introduce you to Cloud native application bundles or cncf.
00:09:10 [W] I'll do a quick demo.
00:09:12 [W] I'll then talk about how synapse solve some of the application packaging and deployment problems.
00:09:18 [W] I'll show you where to learn more about seen ab and finally I'll take questions from the audience.
00:09:24 [W] So let's start with this.
00:09:27 [W] What is a cloud native application?
00:09:35 [W] The first place I looked was in the OED where they Define an application as a program or piece of software designed to fulfill a particular purpose.
00:09:39 [W] That's a pretty broad definition, but it gives us a good starting points to discuss cloudevents occations in general if an application is trying to solve a problem either that the user has all your company has or something back office that you need to that
00:09:50 [W] Some problem you have the first aspect of any application is to compute.
00:09:58 [W] This is where the logic is running. So the binaries are doing their work and they're doing calculations.
00:10:02 [W] If you're at Cube con you'll probably know about containers which are used in but on both soccer and kubenetes.
00:10:12 [W] You may also know about things like functions.
00:10:12 [W] These are event-based computes.
00:10:16 [W] So AWS Lambda is the functions.
00:10:20 [W] There's also things like virtual machines or even bare metal where you can run your application the next aspect to any application is storage.
00:10:31 [W] application will probably have some some form of state that it needs to store or it may require have
00:10:32 [W] It assets are needs to serve to to people so that could be stored in databases.
00:10:41 [W] It could be stored in Albert's object storage like S3 or in posix volumes.
00:10:45 [W] So things like EFS finally because we're talking about the cloud is definitely networking involved. We need to connect all these components up and we need to have a way of exposing our application to the end user.
00:10:55 [W] That brings us to this landscape the cncf landscape.
00:11:00 [W] It's very big.
00:11:01 [W] But the reason it's big and complicated like this is that no application. No to Applications have the same exact needs.
00:11:12 [W] So different applications will have different requirements which will mean they'll probably want to use different tools and different components to build the applications.
00:11:16 [W] It is very overwhelming though and it and it has several implications implications on deployment and packaging.
00:11:19 [W] Let's take a look at deploying these applications.
00:11:26 [W] So I'm not sure if this has happened to everybody in the audience, but it's definitely happened to me you arrive on a new project and you want to know how to build and deploy the application.
00:11:34 [W] The first step is hopefully there's a readme that you can read and learn a little bit about the application there may even be a script or a helper that helps you get started with deploying the application.
00:11:42 [W] But inevitably when you run that command something isn't working because you don't have a tool on your computer or the readme is not up to date or the the script is not up to date.
00:11:52 [W] So you'll probably try to debug a bits download the the missing terraform content that you have over here.
00:11:58 [W] You're pretty try to rerun the script and then you'll run into another one of the common problems, which is the version that you downloaded is not the same as the version that's used on the project. And so the sum option that doesn't work.
00:12:08 [W] Try to fix that problem and you'll probably run into the next problem, which is that, you know yet another binary you don't have on your machine to deploy the application.
00:12:17 [W] So let's talk a little bit about deployment tooling of these applications.
00:12:24 [W] Well, the first challenge is that often you don't need just one tool to deploy an application need multiple.
00:12:28 [W] There's always a challenge then of keeping the read me up-to-date to make sure that you have exactly what's required to deploy and manage the application written down somewhere and that's a manual process.
00:12:38 [W] then of course, there's versioning of tools tools evolved over time and you need to have the same version as everybody else on your team, or as you'll see I
00:12:48 [W] And then one of my favorites as a Linux person, it's always another world to get my application running on Windows because the environment is just so different.
00:12:57 [W] These are difficult coordination problems to solve between you and your team as well as your computer and the CIA and your users, especially if you're building end-user applications.
00:13:09 [W] And this leads to one of my favorite sayings works on my machine, which is a way for developers to basically say I got it working. I'm not that interested in making it work for you.
00:13:18 [W] So what would ideal developments hooting look like? Well, I think it would be defined as code.
00:13:27 [W] So the tools versions an option should all be written in the file somewhere and they should be used as part of the deployment process.
00:13:34 [W] This is where we can learn from the infrastructure as code movement, which is made infrastructure much more reproducible and much better to use.
00:13:38 [W] The other thing that I'd like to see is the same deployment environment everywhere.
00:13:44 [W] I don't want have to think about if this is on Windows Mac or Linux and what the person has installed. I just want the same thing the same thing the same commands to work everywhere.
00:13:50 [W] Let's take a look at packaging now.
00:13:53 [W] So the first thing that I've noticed when I've looked at Cloud native applications is that often you will be storing different parts of the application in different places.
00:14:06 [W] So let's start with the application manifest or the put the thing that defines how the components fit together. In this case. I'm going to use composers the example, but it could be kubenetes gamble or something else often.
00:14:14 [W] This is stored in to get repo because it's just a text file. So in this case, I put GitHub and you can see I have two Services inside there a front and a back.
00:14:19 [W] I just want the same thing the same thing the same commands to work everywhere.
00:14:21 [W] Let's take a look at packaging now.
00:14:21 [W] So the first thing that I've noticed when I've looked at Cloud native applications is that often you will be storing different parts of the application in different places.
00:14:23 [W] So let's start with the application manifest or the put the thing that defines how the components fit together. In this case. I'm gonna use composers the example, but it could be kubenetes down below something else often.
00:14:26 [W] This is stored in a git repo because it's just a text file.
00:14:28 [W] So in this case, I put GitHub and you can see I have two Services inside there a front and a back that reference to in the
00:14:29 [W] The next piece is the deployment tooling. Well, that's a challenge because as I showed before it depends on which computer it's running on. So this some development sitting on my machine which hopefully matches that on the CI a and which hopefully then matches what uses if the if you
00:14:37 [W] Computer it's running on so this some development sitting on my machine which hopefully matches that on the CI and which hopefully then matches what uses if the if you have any end users needs to run.
00:14:40 [W] And then there's application dependencies. So in the case of my application here, it's container based and so the container images would go to something like the docker Hub.
00:14:55 [W] You'll notice here that I have at least three different places where I'm storing pieces of my application and this is a problem because for example, if that image gets deleted the user front 1.19 image gets deleted my application won't deploy anymore. But there's no way that somebody who's using the Manifest from GitHub will know that
00:15:07 [W] So what will my ideal application packaging look like?
00:15:10 [W] Well, I'd love to have an immutable application artifact.
00:15:13 [W] I'd love to build my application test it and know that when I deploy it into production will be exactly the version of everything that I tested before.
00:15:20 [W] I'd also like to be able to store the whole application in one place.
00:15:30 [W] Preferably a registry that will allow me to share it easily and I have a place where I've archived all the versions of my application a bonus would be able to would be that I be able to store my application offline so that I could use it in an air-gapped environments or on iot or other
00:15:39 [W] Exactly the version of everything that I tested before.
00:15:40 [W] I'd also like to be able to store the whole application in one place.
00:15:40 [W] Preferably a registry that will allow me to share it easily and I have a place where I've archived all the versions of my application a bonus would be able to would be that I'd be able to store my application offline so that I could use it in air gapped environments or on iot or other
00:15:43 [W] So that brings me to Cloud native application bundles.
00:15:45 [W] What is cloud native application Bales?
00:15:50 [W] Well, we call it seen a Perfection of glue the cloud native application bundle will have seen AB our packaging format specification that describes a technology for bundling installing and managing distributed applications that are built by Design cloudevents snyk,
00:16:04 [W] Take away from this is that it is a specification and it is cluttered Gnostic.
00:16:10 [W] It's not interested in where you'll be running your application or which tools will be used. It really is designed to be something that solves a problem for everything.
00:16:19 [W] So who is the target? Well, the target is clearly people who are building tools like me.
00:16:24 [W] The specification is broken up into multiple pieces. The first part is the packaging specification or what we call the bundle.
00:16:34 [W] The next part is the bundle runtime and we refer to these the actions that you do with the bundle runtime.
00:16:40 [W] We have an install upgrade and uninstall. So this is basically the lifestyle life cycle of your IRB application.
00:16:50 [W] We then optionally have a bunch of other pieces of the specification.
00:16:54 [W] So one piece is lifecycle tracking which we call Clans.
00:16:57 [W] We then have registry storage and security as well as dependencies.
00:17:01 [W] Let's take a look at the bundle structure. So how the applications are packaged. We call this the bundle definition which is usually a bundle or Json file.
00:17:10 [W] The first part of this is the invocation image.
00:17:20 [W] This is an often a container image because that's what we most comfortable with but it doesn't have to be the invocation image contains both the application definition.
00:17:28 [W] We also then have some metadata about the application.
00:17:38 [W] So things like a name the author version so on.
00:17:40 [W] We have a list of credentials required to deploy the application to this is a way that the bundle can communicate what permissions and things like that. It needs for the deployment and management of the application.
00:17:53 [W] We have parameters.
00:17:55 [W] So these are minor changes our user may wish to make to the application at runtime.
00:18:01 [W] So it could be changing which Port the application is serving on or things like that.
00:18:02 [W] And then we have a reference to the components that the application depends on.
00:18:07 [W] The next part of the specification describes the scene up runtime.
00:18:12 [W] The scene of runtime includes three standard actions.
00:18:18 [W] These are installed upgrade and uninstalled.
00:18:21 [W] you can also have custom actions though for your application.
00:18:24 [W] So these could be things that are well-known like status or logs and they can be stateless or stateful.
00:18:29 [W] So for example fetching the status of the logs from an application would be stateless.
00:18:32 [W] You're not changing the state of the application, but you could have state full actions where you change the state of the application. The application lifecycle is tracked by claims.
00:18:43 [W] So basically this keeps track of which operations have been running your application installation. And when they were done if they were successful on and so forth. It keeps a record of which parameters and outputs which generates it and used for the for each step
00:18:56 [W] You made a change to the application.
00:18:59 [W] But we only Define the data structure for this.
00:19:03 [W] We don't Define how you do this exactly.
00:19:04 [W] There are multiple implementations of this already though.
00:19:06 [W] Let's take a look at a demo. Now where I show you a tool that actually implements a specification.
00:19:12 [W] Okay, now that I've introduced cncf as a specification, let's take a look at a tool that actually implements the specification that you can use.
00:19:29 [W] So the tool that I'll be presenting today is called porter and was developed by Microsoft. If you'd like to get it you can go to pour it out.
00:19:31 [W] Sh so you can see I'm running the latest version.
00:19:33 [W] The way that you define your bundle with Porter is using a port adagiamo file.
00:19:38 [W] So we'll see over here.
00:19:38 [W] I've created one.
00:19:43 [W] There are loads of comments here because I put all my demo material on GitHub.
00:19:47 [W] I'll give you the link at the end of this talk so that you can run the demo see yourself as well.
00:19:51 [W] The demo that I'm going to run is going to be to install a WordPress blog into an existing communities cluster and I've made the installation process a little bit more complicated to show how seen a Biz useful to do complicated installation processes.
00:20:01 [W] Do is I've decided to use terraform to create a namespace and then home to install the application into that namespace.
00:20:09 [W] So the first section we see here is the application method 8 so we have a name a bundle name.
00:20:16 [W] name you have a version we have a description and a tag the tag is used if you're going to be sharing this application through a registry. I'll show some of that later on.
00:20:24 [W] We then have this mixin section mix-ins are a way of communicating supporter, which tools you need for your application to be installed and managed.
00:20:34 [W] So here I've specified terraform and Helm and I've specified a version of terraform because I need to use a feature in the 0.13 version.
00:20:42 [W] We'll only be manipulating kubenetes objects.
00:20:47 [W] So the only set of credentials we need to keep config.
00:20:56 [W] You'll see I've given it a name here of Kube conflict. And the path that I provided is the place that the the config will be mounted into our invocation image.
00:21:01 [W] And then the installer I specify two sets of parameters.
00:21:02 [W] We have a context which is a kubenetes context, which is defaulting to my dacha desktop context and we have a namespace which in this case is Cube con by default.
00:21:11 [W] A Nifty feature of seen a business output feature often when you're installing things will be Auto generated pieces or bits of information that you need to pass between steps.
00:21:28 [W] See now provides us out the box with the outputs so you can take information from one step and output it to another
00:21:29 [W] I two sets of parameters. We have a context which is a kubenetes context, which is defaulting to my doctor desktop context and we have a namespace which in this case is Q Khan by default.
00:21:33 [W] A Nifty feature of seen a business outputs feature often when you're installing things will be Auto generated pieces or bits of information that you need to pass between steps.
00:21:36 [W] See now provides us out the box with the outputs so you can take information from one step and I'll put it to another
00:21:37 [W] We now get to the actions. So we have the install action first as you'd expect. We have two steps.
00:21:38 [W] We have a terraform and we have a Helm step.
00:21:46 [W] The first step is where we're going to be creating our names face. So I'm passing the kubenetes context we want to use and the name space that we want to create and then over here, you'll see I have an output of the name space that's going to write the names loodse recreates as an output so we can use
00:21:54 [W] Expect we have two steps.
00:21:54 [W] We have a terraform and we have a Helm step.
00:21:55 [W] The first step is where we're going to be creating our names face. So I'm passing the kubenetes context we want to use and the name space that we want to create and then over here, you'll see I have an output of the name space that's going to write the names faces recreates as an output so we can
00:21:56 [W] The second step is the helm chart install.
00:21:59 [W] So it's just a simple Helm section with the chart that we want to install and that namespace that we specified earlier.
00:22:05 [W] Upgrading this would be a lot simpler.
00:22:09 [W] We don't need to do any namespace app changes.
00:22:12 [W] So I've just got to helm step here.
00:22:15 [W] And that's just going to take the same stable WordPress charts and do the update using that.
00:22:19 [W] Finally, we have an install action here. We have two steps with the first step being Helm. So the inverse of what we had in the install that will remove the helm charts and then we have terraform which will then delete that namespace that it was responsible for speaking of
00:22:35 [W] First Step being Helm. So the inverse of what we had in the install that will remove the helm charts and then we have terraform which will then delete that namespace that it was responsible for speaking of terraform. It's just take a quick look at what I have inside the styrofoam folder.
00:22:38 [W] So I have a main dot t-- f which is where the logic is.
00:22:45 [W] We only have one resource being managed by terraform, which is my kubenetes namespace and that is set with a variable name space.
00:22:49 [W] As we using communities we need the community's provider and here. I'm also using a variable to set which context will be will be using.
00:22:56 [W] Great.
00:22:58 [W] We're now ready to go.
00:23:00 [W] So let's open up a terminal and see what the current state of my machine is.
00:23:06 [W] So even though I'm using terraforming Helm.
00:23:09 [W] I actually don't have either of these tools installed on my computer if I check which terraform get nothing and if I do a which Helm will see that I also don't have anything. I do have dr.
00:23:20 [W] Desktop running on my computer and that has its own kubenetes cluster activated.
00:23:24 [W] So I have a kubenetes cluster running. So we do a cute couple.
00:23:25 [W] Get namespaces we can see that we have just the default names faces up and running.
00:23:31 [W] All right.
00:23:41 [W] I mentioned earlier that we need some way of passing credentials into Port supported as install the credentials itself, but it needs to have a reference that knows what will be used. So I have this I've already set up my qad's conflict inside Porter credentials.
00:23:48 [W] At what we have inside their credentials list. So I have what I've named Cube cred. And if we do a porter credentials show on this will see that I have linked this to the
00:24:04 [W] my home directory
00:24:07 [W] So with that we have everything we need we've got dr.
00:24:12 [W] Desktop running the kubenetes cluster.
00:24:17 [W] I've got portrait installed and I've linked ported to my kubenetes conflict.
00:24:19 [W] So now I can run the porter install command.
00:24:20 [W] I need to specify a an application instance.
00:24:25 [W] So I'm going to use my app for this case.
00:24:29 [W] case. I need to pass it the credentials that it's going to use we're going to pass a cube cred and then I'm going to change the name space that we were that we're going to be creating installing this application into so it was Cube con. I'm going to change it to
00:24:38 [W] Hello.
00:24:39 [W] keep calm. So you see his name space equals.
00:24:44 [W] Hello.
00:24:45 [W] Keep calm.
00:24:48 [W] All right, what this is going to do is it's going to run the installation process inside a container from a container.
00:25:00 [W] So that means that that container has all the tools and things that it needs to do this application installation, and I don't need to have them locally on my computer.
00:25:03 [W] So the first step will see is that it's going to be creating the name space with terraform The Next Step.
00:25:10 [W] will see will be the helm step. So here we go.
00:25:14 [W] in a space has already been created and here we see Helm installing from that stable WordPress chart.
00:25:19 [W] Great that says it was a success Porter will tell us then inside. If you do the portal list command that my app has been installed Last Action was successful and that was just completed five seconds ago.
00:25:34 [W] Start checking on the state of our kubenetes cluster. So if we do get namespaces, we're expecting to see a hollow Cube. Con namespace.
00:25:43 [W] Yeah.
00:25:43 [W] Yep.
00:25:45 [W] There we go. The New Hollow Cube conflict namespace and if we do a get all on that namespace, we can see that some of the components of started coming up just like a cooking show.
00:25:54 [W] show. I'm going to go away now and when I come back everything will be up and running.
00:25:58 [W] All right. I'm back and our WordPress is now running.
00:26:11 [W] So here we can see we have a Maria di be running and a WordPress front end running.
00:26:16 [W] So let's take a look at that's actually all up and running on my Local Host before this demo.
00:26:21 [W] I open up my browser and I never get it to Local Host and obviously nothing was running there yet.
00:26:26 [W] If I just refresh this page, we should see the default WordPress installation.
00:26:26 [W] So here we go.
00:26:28 [W] have a Hello World post and if I click on the sample page, you'll see that I just have the default sample page here. So everything's running.
00:26:37 [W] My local host on kubenetes great.
00:26:39 [W] So Porter doesn't just handle the installation and can also do upgrade and uninstall.
00:26:46 [W] Let's uninstall this application now as we don't need it anymore, so to do that.
00:26:50 [W] All we need to do is we need to specify and install the application instance name and we need to pass those credentials again because portal needs access to the communities across the cluster
00:27:03 [W] Steps in Reverse.
00:27:10 [W] the first we will see how I'm doing a delete and then we'll see terraform doing the deletion of the namespace terraformed will probably take a moment to delete the name space because it's going to wait until the name space is empty before it's before it completes the task, so it probably takes about 10 seconds or so.
00:27:21 [W] All right, great. So we just installed an application with none of the tools on my local machine and then we uninstalled it with none of the tools in my machine.
00:27:34 [W] Let's look at the next interesting feature that we have with seen Evan Porter.
00:27:41 [W] Well, as I said earlier, you can push applications to registry.
00:27:53 [W] Let's get one from the registry and run it locally without having any of the source. So I'm going to navigate into my pull directory where we don't have anything so you can see that I'm not using another Port about the animal or anything like that.
00:27:55 [W] On the docker Hub.
00:27:58 [W] You'll see that there's Labs have put up a porter.
00:27:59 [W] Hello bundle. And basically this is just a hello world application.
00:28:04 [W] All it does is output hello world text effectively. What we can do then is we can run the porter install command we can give it an app instance.
00:28:16 [W] So once again, I'll give it the name of my app.
00:28:18 [W] I'm going to give it the tag and I'm going to paste that registry reference latest.
00:28:23 [W] There you go what this is going to do in the
00:28:25 [W] Seen Evan Porter.
00:28:34 [W] Well, as I said earlier, you can push applications to a registry.
00:28:35 [W] Let's get one from the registry and run it locally without having any of the source. So I'm going to navigate into my pool directory or we don't have anything so you can see that I'm not using another Port about the animal or anything like that.
00:28:36 [W] On the docker Hub.
00:28:37 [W] You'll see the dais Labs have put up a porter.
00:28:37 [W] Hello bundle. And basically this is just a hello world application.
00:28:38 [W] All it does is output hello world text effectively. What we can do then is we can run the porter install command we can give it an app instance.
00:28:42 [W] So once again, I'll give it the name of my app.
00:28:43 [W] I'm going to give it the tag and I'm going to paste that registry reference latest.
00:28:44 [W] There you go what this is going to do in the
00:28:45 [W] Background is it's going to fetch the bundle and run it and run the installation process late locally.
00:28:53 [W] That's this is how you know, it's a real demo because I made it I made a typo.
00:28:53 [W] There you go.
00:28:54 [W] that's already run.
00:28:54 [W] So it's already downloaded and run as we can see here at ran the installation action first and that was that just outputs hello world of ego. If we do a portal list, we can see that we have
00:28:56 [W] my app instance installed and if we do a portrait upgrade of my app doesn't take any parameters or anything we can see that we have now upgraded to World 2.0 and if we do it for a list again, we should see that
00:29:10 [W] This is how you know, it's a real demo because I made it I made a typo.
00:29:10 [W] There you go.
00:29:11 [W] That's already run.
00:29:11 [W] So it's already downloaded and run as we can see here at ran the installation action first and that was that just outputs hello world of ego. If we do a portrait a list we can see that we have my app
00:29:12 [W] Action was an upgrade.
00:29:14 [W] Let's uninstall this now as we're done with it using Porter again.
00:29:18 [W] So we'll just do an install of my app and that will remove it.
00:29:23 [W] I didn't need any of the the source code or tools or anything on my machine. It just fit everything for the registry and round.
00:29:25 [W] It's just like that.
00:29:27 [W] I've seen out is that you can up puts a bundle to disk so that you can use it offline or in are gaps. It's scenarios.
00:30:43 [W] So Porter has the useful archive command to do this and what that does is creates a table containing everything you need for the application.
00:30:44 [W] So I'm going to run a porter archive and save it to my bundle that tgz inside that directory.
00:30:45 [W] This will take a moment.
00:30:45 [W] I'll be back.
00:30:46 [W] All right. It looks like the archive is done.
00:30:47 [W] Let's navigate into that archive directory to see what this looks like.
00:30:49 [W] So as expected we have a bundle dot T gz and if we extract this will see all the files that make up this the scene AB for those familiar with oci.
00:30:51 [W] You'll probably recognize this is an OC I imaged out and if we just take a look at the most interesting file here from the scene a perspective.
00:30:54 [W] It's the bundle lot Jason. This is effectively a where the bundle
00:30:56 [W] Stored and this is the interface that all applications that I've seen are compliant will use. So even though this was created with Porter another synapse tool could read this panel to Jason and wouldn't know what to do.
00:31:06 [W] That's the end of the demo.
00:31:06 [W] Okay. Now that we've seen seen Evan action. Let's talk about how it solved some of the deployment problems.
00:31:07 [W] So if you remember the example that I gave before where I try to deploy an application with the shell script and didn't have any other tools locally see now seems to have solved that we defined everything we needed inside the portal yellow file so as code and then we only had one command to run
00:31:11 [W] So we defined it as code inside the porter got llamo. We defined the versions We wanted me to find out which tools we needed and we Define which options we want to use.
00:31:20 [W] We stored all of this inside the invocation image for of the synapse so that I didn't need to have any of this on my local machine and then in terms of having the same deployment environment everywhere because Porter uses containers, it means that we have the same environment if
00:31:36 [W] The next so we don't need to think about what what the developer or the end user is using that is a much better user experience both for people on your team the CIA and for users.
00:31:51 [W] let's talk about some of the packaging for seen that so I didn't show you inside the demo how to push a scene up to a registry, but I can talk to you about how how this actually works.
00:32:02 [W] scene app is represented by an OC I index. So this is one of the standard container objects that already exists we've destroyed used what exists there.
00:32:10 [W] From that index.
00:32:15 [W] We reference it a bunch of objects. The first object is the bundle definition so that set bundle that Json file reference the invocation image in the scene app case the soil in the porter case. This is just a container image and then we also have the components from 1 to n.
00:32:24 [W] Components make up your application.
00:32:28 [W] We can also store those in the registry because of how those things are stored there oci images and each one of those will reference the list of blobs, which is just binary data that's stored as part of that.
00:32:40 [W] thing to remember though is that storing the components is optional with see now you can either have what we call thin bundles where you only have the bundle definition and the invocation image or you can have the thick bundle which includes the components as well.
00:32:53 [W] So conversely to what we saw before with different pieces in different places.
00:33:00 [W] see number now enabled us to store everything in one place. So before we had the application manifest on GitHub, we had the tooling on different people's computers and on the CI a-- nodes and on our end users computers and
00:33:12 [W] And it's on the docker Hub now with using existing oci standards.
00:33:21 [W] We can store everything inside an OC. I complained registry like the docker Hub, or we can store it offline inside a table.
00:33:24 [W] Going back to what we talked about as being ideal application packaging.
00:33:30 [W] Let's take a look how CNET Fitz's in terms of an immutable application artifact.
00:33:36 [W] Well because we're reusing the container infrastructure that already exists we're using hash is for the components. So we know that what we stored is exactly what we will be using later on.
00:33:44 [W] We're also not trying to reinvent the wheel here. We're already using things that I've been well tested and exist brought were widely, which is great.
00:33:52 [W] We managed to stall the whole application inside a registry and not just the docker Hub, but you can actually store these seen ABS in any oci compliant containerd registry.
00:34:02 [W] We also had the ability to store the application offline, which would make it useful for things like a gap environment so iot, and we did this using the oci image layout which is something also defined from container. So we didn't we didn't invent anything here.
00:34:18 [W] I didn't show in the demo, but Cena is also very serious about security.
00:34:22 [W] We decided to leverage the same mechanisms that exist for containers.
00:34:28 [W] So we have things like tough for the update framework and in-toto.
00:34:33 [W] All of this has been implemented using notary which is an existing technology, which is used for containers.
00:34:36 [W] We do have some reference tooling about for this which you can take a look at called signee and you can find it on the GitHub the scene object GitHub at cri-o / signing.
00:34:47 [W] If you'd like to learn more about seen AB, I'd suggest you go to these resources.
00:34:55 [W] The first one is the seen our website at cri-o.
00:34:59 [W] My demo code is up on my personal GitHub. Please feel free to clone it and give it a try and let me know if you run into any issues.
00:35:09 [W] If you'd like to try a porter you just you go to Porter got sh, there's all the instructions you need there to get going.
00:35:18 [W] If you're interested in storing things in Registries is a couple of talks in my colleagues and ex-colleagues will be giving the recommended. The first one is sharing is caring by tufin.
00:35:19 [W] My colleagues Silva and George Who both work a darker. The second one is where to put all that.
00:35:25 [W] Yeah mlops. That's by one of my old colleagues Ryan Abrams.
00:35:28 [W] Does anybody have any questions?
00:35:31 [W] Right.
00:35:38 [W] Hi everyone.
00:35:41 [W] So I'm going to go through some of the questions live now.
00:35:47 [W] If you're interested in storing things in Registries is a couple of stalks of my colleagues and ex-colleagues will be giving that are recommended. The first one is sharing is caring by two of my colleagues Siva and George Who both work at Dhaka the second one is where to put all that
00:35:49 [W] One that I was starting to answer I'll publish a quickie.
00:35:59 [W] So I mentioned that I didn't have portal or Helm installed on my computer.
00:36:02 [W] And so Rafael asked where are those dependencies installed then so basically how the install an image on seanet internet works is includes the two links that in this case. It'll include the helm chart.
00:36:10 [W] Sorry to intrude Helm and water as well as the terraform files and help chart. So it's all built inside the container.
00:36:20 [W] Image so I don't need them locally.
00:36:20 [W] We're ready.
00:36:24 [W] What is the maturity?
00:36:25 [W] So this is from Rita.
00:36:26 [W] What does maturity status of all the available? So you haven't implementations.
00:36:37 [W] I know that I think the Porter is the furthest along that's why I kind of showed it. So see you have is relatively new and it's difficult to make things like specks super interesting for people, but for sure, I think it's not quite GA, but it's closed. So I would recommend
00:36:44 [W] That is H and you'll get more information there already.
00:36:50 [W] Let's see what the next one is.
00:36:53 [W] Thank you everybody for the compliments.
00:36:54 [W] I do appreciate that.
00:36:57 [W] I'm glad that everybody found this useful.
00:37:00 [W] I will skip over those that I'm trying to find them kind of dig into the questions. One of the questions. I saw quite a lot is what is difference between water and Helm. So the way that I like to describe to you now because it's kind of like the MSI or RPM or Deb of the cloud.
00:37:12 [W] It's just a way of packaging with things together. It doesn't really care what's inside
00:37:18 [W] It just cares about how to put everything together in one unit.
00:37:20 [W] that can be then stored in the registry or elsewhere.
00:37:25 [W] Whereas Helm account cares about which components will be deployed.
00:37:29 [W] So it's yeah, it's yeah, that's kind of relationship.
00:37:33 [W] I see so it's one level above it like a superset. I think somebody describe a specific is good.
00:37:38 [W] Somebody asked what it's like Paolo asked.
00:37:40 [W] it like developing a seen a bundle? So do we have scaffold or tilt supports? I
00:37:47 [W] I think there is scaffold of Child Support yet, but there's no reason you couldn't you couldn't do that.
00:37:52 [W] Let me see.
00:37:52 [W] What else there is.
00:37:53 [W] It's an convertibles.
00:37:56 [W] Right.
00:38:06 [W] also, it's how will you group the things together and store them as an artifact and when I say that I as I tried to show in the presentation, you know, just having your container images on Docker hub for example, and you linbit about it, but we want to show you what application manifest and gets had means that you kind of have a split so
00:38:30 [W] Consolidate the things like that.
00:38:35 [W] Let me see what else there is here in vacation images can be very large in the case of the complex ci/cd.
00:38:41 [W] Yes, that is true.
00:38:54 [W] I think the Porter is going to be doing work on optimizing some of that those as well. So it basically depends on how big the tools are and things like that but the good thing with containers is that Slayers are cached or layers are cached.
00:38:57 [W] So once you've pulled them once when have to re pool butts again, or I will portworx.
00:39:00 [W] To play with volts that doesn't have any integration and I think I'm not 100% sure you'll have to ask that on the on the porter repo.
00:39:13 [W] see what else there is.
00:39:15 [W] Sorry, I'm trying to filter through the questions and tilt Ricky.
00:39:22 [W] How can we manage multiple environments with Porter or put disport already have a mechanism for this I think is the question so there is no built in environment managing important that I found but what
00:39:40 [W] It was because you know, it was open up you could set up around the toes and things like that to make it sort of works for different environments that you have. So it would be possible to Burnt. There's just no first class like notion of an environments.
00:39:51 [W] Let me see.
00:39:53 [W] What else there is.
00:39:55 [W] So yeah Porter could be seen as a rapper on top of Helm in some cases.
00:40:02 [W] That is true.
00:40:03 [W] Let me see if there's anything else does it also should get because terraform with modules users get so this is from Herman.
00:40:21 [W] So it's doesn't I didn't double-check the the image but it is possible to have an indication of which that has given site and if that's needed so the CIA itself doesn't really care about what's inside
00:40:28 [W] Needs is the tools and the application definitions and then it it just basically runs the things that need to be run to do the very steps. It doesn't there's no definition of exactly what needs to be inside.
00:40:39 [W] Okay, I think that's all the questions that I got.
00:40:46 [W] Here's one from Darren Bell.
00:40:56 [W] Does it only apply Delta's so know it's it's up to what you've put inside the scene add to decide what the update strategy is.
00:41:02 [W] So if your tool so in this in the example that I gave for example, Helm will handle the reconciliation.
00:41:06 [W] I think it just it's just the standard reconciliation groups that says to keep an eighties make it this and then kubenetes as a
00:41:10 [W] Consideration itself. So it's seen as quite a few levels are above that. So it doesn't do it doesn't know about keeping it. He's actually seen at itself. It just it just runs a the update command on the the tool inside the invocation image and
00:41:25 [W] It doesn't know what actually happens after that.
00:41:28 [W] There's a question about if it's air-gapped.
00:41:35 [W] And so this is from Christian.
00:41:43 [W] And is it possible to include the application image within the porter image for are gaps installations and not 100% sure if the helm mixing does that but it is possible with the
00:41:50 [W] the porter image for are gaps installations and not 100% sure if the helm mixing does that but it is possible with the specification to do that and we did actually think pretty hard about about how to make sure
00:41:56 [W] That actually think pretty hard about about how to make sure you can probably a gap things because that's a definite use case.
00:41:59 [W] Alrighty, so I'm just trying to I'm struggling to sort through the questions here in and read them up and live time in real time. Ellis asks, I'll publish it too quickly.
00:42:14 [W] It was asks, if uses one to choose their own cloud provider will then need to change Posey.
00:42:17 [W] I'm like holding me.
00:42:24 [W] So if you're using Helm probably not. So once again, see how it doesn't doesn't mind what you're using underneath it's more about it's more about just
00:42:30 [W] To get together. So if your home tried it has its that for example in the demo that I showed you how much charge users bits that are cloud provider specific you will need to change that Helm chart. The party animal itself probably won't need to change but that really depends on how you define your application
00:42:45 [W] New message me somebody I know so. Yeah, I know. Thanks for coming to my talk.
00:42:52 [W] Let's see.
00:42:54 [W] What else we have here.
00:42:56 [W] I think that's all of the ones that I can answer here.
00:43:00 [W] I will also be on the cncf slack. So if anybody has any questions, I'm happy to help you.
00:43:07 [W] There's there's also I'll give you a link to the the repo which I put inside the questions of you. See if I can share that more body. But otherwise, I'll share inside the the slacks that everybody has that.
00:43:16 [W] But thank you everybody for attending.
